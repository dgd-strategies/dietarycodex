<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
              rel="stylesheet" />
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
              rel="stylesheet" />
        <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
        <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
        <script>if ("serviceWorker" in navigator){navigator.serviceWorker.register("sw.js").catch(()=>{});}</script>
        <link href="assets/style.css" rel="stylesheet" />
    </head>
    <body>
        <header class="hero text-center">
            <a href="https://hobi.med.ufl.edu/"
               target="_blank"
               rel="noopener"
               style="display:block;
                      text-align:center;
                      margin-top:2rem">
                <img src="assets/UF_gen_ai.png" alt="UF Logo" />
            </a>
            <p class="lead">
                The Department of Health Outcomes & Biomedical Informatics
                (HOBI) at the University of Florida advances research and
                data science for better care. Tap the logo to explore our
                programs and open-source tools.
            </p>
            <p class="lead mt-3">
                OpenAI released its Codex research preview in May 2025 and expanded it to ChatGPT users in June. HOBI quickly modernized prior code under <strong>Dr. Larissa Strath</strong>'s leadership, sharing this project so researchers worldwide can collaborate and advance health data science.
            </p>
            <a class="btn btn-primary hero-btn"
               href="https://hobi.med.ufl.edu/"
               target="_blank">Learn more about HOBI</a>
        </header>
        <section class="container py-4" id="about">
            <h2>About this Project</h2>
            <p>
                The scoring methods featured on this platform are derived from the robust
                <a href="https://github.com/jamesjiadazhan/dietaryindex"
                   target="_blank"
                   rel="noopener">Dietary Index</a>
                R codebase created by James Jia Da Zhan, whose foundational contributions we gratefully acknowledge.
                Leveraging generative AI and codex-driven configurations, we have modernized these methodologies into
                an intuitive drag-and-drop web interface, powered entirely by Pyodide. This approach removes significant
                technical and language barriers, enabling researchers from diverse backgrounds to seamlessly engage with validated nutritional scoring routines, without requiring any server setup or coding expertise.
            </p>
            <p>
                Our codex-configured system integrates generative AI to facilitate transparent validation, robust self-correction,
                and comprehensive refinement tools across the entire codebase. A key advantage of this design is built-in peer validation,
                inherently provided through reliance on peer-reviewed scholarly publications, thus ensuring immediate credibility and trust.
                These intrinsic validation processes accelerate the adoption and practical application of proven research methodologies.
            </p>
            <p>
                We actively encourage critical feedback, validation testing, and innovative suggestions—whether verifying existing scoring
                procedures or proposing new nutritional indices. Researchers and practitioners are invited to fork our repository, file issues,
                and contribute actively to future improvements. Through open sharing of this collaborative AI-driven framework, HOBI and
                <strong>Dr. Strath</strong> aim to cultivate an inclusive, transparent nutrition science community, bridging publication and
                practice, and ultimately accelerating research that enhances public health outcomes.
            </p>
            <p>
                <strong>Disclaimer:</strong> The majority, if not all, content on this platform—including written materials and both frontend
                and backend code—is generated by AI. While innovative, not all content has undergone comprehensive human validation, including
                this very disclaimer. This project is currently in early alpha development, with validation methods actively evolving. Users should independently verify all results obtained through these tools and employ them at their own risk. Your feedback—positive or critical—is invaluable in refining scientific validation methodologies facilitated by generative AI.
            </p>
        </section>
        <main class="container py-4">
            <div class="controls d-flex flex-wrap gap-2 align-items-center mb-3">
                <span>All scores calculate automatically if columns exist.</span>
                <span id="pyStatus" class="ms-auto small text-info">Loading Pyodide...</span>
            </div>
            <div class="mb-4">
                <ol class="mb-0">
                    <li>
                        Prepare your CSV using template
                        <a href="data/template.csv">the provided template</a>
                        (download and replace the sample values with your own
                        nutrient data).
                    </li>
                    <li>Drag it below or use the file picker.</li>
                    <li>Download the scored file and review the charts.</li>
                </ol>
                <div class="alert alert-light border rounded-4 mt-3" role="note">
                    <strong>About the template:</strong> this CSV outlines all
                    required nutrient columns. Use it as a guide so the scoring
                    engine recognizes your data. Delete the example rows and add
                    your own records before uploading.
                </div>
            </div>
            <div id="dropzone" class="mb-3">Drag & drop CSV here, or click to select file</div>
            <div id="previewContainer">
                <h3 id="previewTitle" style="display:none;">
                    Preview (first 5 rows)
                    <button id="clearBtn"
                            type="button"
                            class="btn-close float-end"
                            aria-label="Clear preview"
                            style="display:none"></button>
                </h3>
                <table id="previewTable">
                </table>
            </div>
            <button id="scoreBtn" class="btn btn-primary mb-2" disabled>Score & Download</button>
            <div id="loading">⏳ Scoring in progress...</div>
            <div id="result"></div>
            <div id="charts"></div>
        </main>
        <script>
    const dropzone = document.getElementById('dropzone');
    const resultBox = document.getElementById('result');
    const previewTable = document.getElementById('previewTable');
    const previewTitle = document.getElementById('previewTitle');
    const clearBtn = document.getElementById('clearBtn');
    const loading = document.getElementById('loading');
    const pyStatus = document.getElementById('pyStatus');
    const scoreBtn = document.getElementById('scoreBtn');
    let currentData = null;
    let currentName = 'template.csv';
    let pyReady = null;
    async function loadPy() {
      if (!pyReady) {
        pyReady = loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/' })
          .then(async py => {
            await py.loadPackage(['pandas', 'numpy']);
            const files = ['base.py','dii.py','dash.py','mind.py','hei.py','dii_parameters.json'];
            for (const f of files) {
              const prefix = f === 'dii_parameters.json' ? './data/' : './compute/';
              const resp = await fetch(prefix + f);
              const text = await resp.text();
              const dir = '/tmp/compute';
              try { py.FS.stat(dir); } catch { py.FS.mkdirTree(dir); }
              py.FS.writeFile(dir + '/' + f, text);
            }
            await py.runPythonAsync("import sys; sys.path.insert(0, '/tmp')");
            return py;
          });
      }
      return pyReady;
    }


    function quantile(arr, q) {
      const sorted = arr.slice().sort((a, b) => a - b);
      const pos = (sorted.length - 1) * q;
      const lo = Math.floor(pos), hi = Math.ceil(pos);
      return sorted[lo] + (sorted[hi] - sorted[lo]) * (pos - lo);
    }
    function computeStats(values) {
      const n = values.length;
      const mean = values.reduce((a,b) => a + b, 0) / n;
      const sq = values.map(v => (v - mean)**2);
      const std = Math.sqrt(sq.reduce((a,b) => a + b, 0) / (n - 1));
      return {
        mean: mean.toFixed(2),
        std: std.toFixed(2),
        min: Math.min(...values).toFixed(2),
        max: Math.max(...values).toFixed(2),
        median: quantile(values,0.5).toFixed(2),
        quintiles: [0.2,0.4,0.6,0.8].map(q => quantile(values,q).toFixed(2))
      };
    }

    function csvToJson(text) {
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',');
      return lines.slice(1).map(line => {
        const values = line.split(',');
        const obj = {};
        headers.forEach((h, i) => {
          const v = (values[i] ?? '').trim();
          if (v === '') {
            obj[h] = null;
          } else {
            const num = Number(v);
            obj[h] = isNaN(num) ? v : num;
          }
        });
        return obj;
      });
    }

    function jsonToCsv(data) {
      if (!data.length) return '';
      const headers = Object.keys(data[0]);
      const lines = data.map(row => headers.map(h => row[h]).join(','));
      return [headers.join(','), ...lines].join('\n');
    }

    function applyColumnMapping(data) {
      const map = JSON.parse(localStorage.getItem('colMap') || '{}');
      return data.map(row => {
        const out = { ...row };
        for (const [dst, src] of Object.entries(map)) {
          if (src in row && !(dst in row)) {
            out[dst] = row[src];
          }
        }
        return out;
      });
    }

    function showMappingUI(missing, headers) {
      const saved = JSON.parse(localStorage.getItem('colMap') || '{}');
      let html = '<h3>Map Columns</h3><form id="mapForm">';
      missing.forEach(col => {
        html += `<div class='mb-2'><label class='me-2'>${col}</label>`;
        html += `<select class='form-select d-inline w-auto' data-key='${col}'>`;
        html += "<option value=''>--</option>";
        headers.forEach(h => {
          const sel = saved[col] === h ? 'selected' : '';
          html += `<option ${sel}>${h}</option>`;
        });
        html += '</select></div>';
      });
      html += "<button type='submit' class='btn btn-primary mt-2'>Save Mapping</button></form>";
      resultBox.innerHTML = html;
      document.getElementById('mapForm').addEventListener('submit', e => {
        e.preventDefault();
        const selects = document.querySelectorAll('#mapForm select');
        selects.forEach(sel => {
          if (sel.value) saved[sel.dataset.key] = sel.value;
        });
        localStorage.setItem('colMap', JSON.stringify(saved));
        resultBox.innerHTML = '';
        computeFile(currentData, currentName);
      });
    }
    dropzone.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv';
      input.onchange = () => handleFile(input.files[0]);
      input.click();
    });
    clearBtn.addEventListener('click', () => {
      resultBox.innerHTML = '';
      previewTable.innerHTML = '';
      previewTitle.style.display = 'none';
      document.getElementById('charts').innerHTML = '';
      clearBtn.style.display = 'none';
    });
    dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('hover'); });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('hover'));
    dropzone.addEventListener('drop', e => {
      e.preventDefault(); dropzone.classList.remove('hover');
      if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
    });

    scoreBtn.addEventListener('click', () => {
      if (currentData) computeFile(currentData, currentName);
    });

    // Load bundled template on startup
    window.addEventListener('DOMContentLoaded', async () => {
      await loadPy();
      pyStatus.textContent = 'Local compute ready';
      pyStatus.className = 'ms-auto small text-success';
      try {
        const res = await fetch('./data/template.csv');
        if (!res.ok) throw new Error(`template load ${res.status}`);
        const text = await res.text();
        const file = new File([text], 'template.csv', { type: 'text/csv' });
        handleFile(file);
      } catch (err) {
        console.error('Could not preload template', err);
      }
    });

    async function handleFile(file) {
      resultBox.innerHTML = '';
      previewTable.innerHTML = '';
      previewTitle.style.display = 'none';
      document.getElementById('charts').innerHTML = '';
      clearBtn.style.display = 'none';
      loading.style.display = 'none';
      if (!file.name.toLowerCase().endsWith('.csv')) {
        resultBox.innerHTML = "<div class='error'>Only CSV files are supported.</div>";
        return;
      }
      currentName = file.name;
      const text = await file.text();
      currentData = csvToJson(text);
      const rows = text.trim().split('\n').map(r => r.split(','));
      const headers = rows[0];
      const sample = rows.slice(1,6);
      let html = '<tr>' + headers.map(h => `<th>${h}</th>`).join('') + '</tr>';
      sample.forEach(r => html += '<tr>' + r.map(c => `<td>${c}</td>`).join('') + '</tr>');
      previewTable.innerHTML = html;
      previewTitle.style.display = 'block';
      clearBtn.style.display = 'inline-block';
      scoreBtn.disabled = false;
    }

    async function computeFile(data, name) {
      loading.style.display = 'block';
      try {
        const headers = Object.keys(data[0] || {});
        const mapped = applyColumnMapping(data);
        const py = await loadPy();
        const jsonData = JSON.stringify(mapped).replace(/'/g, "\\'");
        const pyRes = await py.runPythonAsync(`
import pandas as pd, json
from compute.dii import calculate_dii, DII_PARAMETER_KEYS
from compute.mind import calculate_mind, MIND_COMPONENT_KEYS
from compute.hei import (
    calculate_hei_2015,
    calculate_hei_2020,
    calculate_hei_toddlers_2020,
    HEI_COMPONENT_KEYS,
)
from compute.dash import calculate_dash, DASH_COMPONENT_KEYS
from compute.base import compute_summary_stats
data = json.loads('${jsonData}')
df = pd.DataFrame(data)
stats = {}
missing = {}
def check(cols):
    return [c for c in cols if c not in df.columns]

if not check(DII_PARAMETER_KEYS):
    df['DII'] = calculate_dii(df)
    stats['DII'] = compute_summary_stats(df, ['DII'])['DII']
else:
    missing['DII'] = check(DII_PARAMETER_KEYS)

if not check(MIND_COMPONENT_KEYS):
    df['MIND'] = calculate_mind(df)
    stats['MIND'] = compute_summary_stats(df, ['MIND'])['MIND']
else:
    missing['MIND'] = check(MIND_COMPONENT_KEYS)

if not check(HEI_COMPONENT_KEYS):
    df['HEI_2015'] = calculate_hei_2015(df)
    stats['HEI_2015'] = compute_summary_stats(df, ['HEI_2015'])['HEI_2015']
    df['HEI_2020'] = calculate_hei_2020(df)
    stats['HEI_2020'] = compute_summary_stats(df, ['HEI_2020'])['HEI_2020']
    df['HEI_TODDLERS_2020'] = calculate_hei_toddlers_2020(df)
    stats['HEI_TODDLERS_2020'] = compute_summary_stats(df, ['HEI_TODDLERS_2020'])['HEI_TODDLERS_2020']
else:
    m = check(HEI_COMPONENT_KEYS)
    missing['HEI_2015'] = m
    missing['HEI_2020'] = m
    missing['HEI_TODDLERS_2020'] = m

if not check(DASH_COMPONENT_KEYS):
    df['DASH'] = calculate_dash(df)
    stats['DASH'] = compute_summary_stats(df, ['DASH'])['DASH']
else:
    missing['DASH'] = check(DASH_COMPONENT_KEYS)

out = {'csv': df.to_csv(index=False), 'stats': stats, 'missing': missing}
json.dumps(out)
`);
        const info = JSON.parse(pyRes);
        const csvText = info.csv;
        const rows = csvText.trim().split('\n').map(r => r.split(','));
        const idx = rows[0].reduce((m,h,i) => (m[h]=i,m), {});
        const computed = Object.keys(info.stats || {});
        const missing = info.missing || {};
        if (computed.length === 0) {
          const allMissing = [...new Set(Object.values(missing).flat())];
          loading.style.display = 'none';
          showMappingUI(allMissing, headers);
          return;
        }
        let summary = '<h3>Summary Statistics:</h3><ul>';
        computed.forEach(name => {
          const vals = rows.slice(1).map(r => parseFloat(r[idx[name]])).filter(v => !isNaN(v));
          const s = info.stats[name];
          summary += `<li><b>${name}</b> – mean: ${parseFloat(s.mean).toFixed(2)}, std: ${parseFloat(s.std).toFixed(2)}, min: ${parseFloat(s.min).toFixed(2)}, max: ${parseFloat(s.max).toFixed(2)}, median: ${parseFloat(s.median).toFixed(2)}, quintiles: ${s.quintiles.map(q=>parseFloat(q).toFixed(2)).join(', ')}</li>`;
          const chartDiv = document.createElement('div');
          document.getElementById('charts').append(chartDiv);
          Plotly.newPlot(chartDiv,[{x:vals,type:'histogram',name}],{title:`${name} Distribution`,margin:{t:40}}, {responsive:true});
        });
        summary += '</ul>';
        Object.entries(missing).forEach(([n, cols]) => {
          summary += `<div class='alert alert-warning mt-2'>${n} missing columns: ${cols.join(', ')}</div>`;
        });
        resultBox.innerHTML = summary;
        const blob = new Blob([csvText], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name.replace(/\.csv$/, '') + '_scores.csv';
        a.click();
        URL.revokeObjectURL(url);
      } catch(err) {
        console.error('Scoring failed', err);
        let msg = err instanceof Error ? `${err.name}: ${err.message}` : String(err);
        resultBox.innerHTML = `<div class='error'><b>${msg}</b></div>`;
      } finally {
        loading.style.display = 'none';
      }
    }
        </script>
    </body>
</html>
