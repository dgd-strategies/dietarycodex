<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
              rel="stylesheet" />
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
              rel="stylesheet" />
        <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
        <script type="module">
          import init from './pkg/dietarycodex.js';
          init().catch(() => import('./assets/wasm/dietarycodex.js').then(m => m.default()));
        </script>
        <script>if ("serviceWorker" in navigator){navigator.serviceWorker.register("sw.js").catch(()=>{});}</script>
        <link href="assets/style.css" rel="stylesheet" />
    </head>
    <body>
        <header class="hero text-center">
            <a href="https://hobi.med.ufl.edu/"
               target="_blank"
               rel="noopener"
               style="display:block;
                      text-align:center;
                      margin-top:2rem">
                <img src="assets/UF_gen_ai.png" alt="UF Logo" />
            </a>
            <p class="lead">
                The Department of Health Outcomes & Biomedical Informatics
                (HOBI) at the University of Florida advances research and
                data science for better care. Tap the logo to explore our
                programs and open-source tools.
            </p>
            <p class="lead mt-3">
                OpenAI released its Codex research preview in May 2025 and expanded it to ChatGPT users in June. HOBI quickly modernized prior code under <strong>Dr. Larissa Strath</strong>'s leadership, sharing this project so researchers worldwide can collaborate and advance health data science.
            </p>
            <a class="btn btn-primary hero-btn"
               href="https://hobi.med.ufl.edu/"
               target="_blank">Learn more about HOBI</a>
        </header>
        <main class="container py-4">
            <div class="card shadow-sm p-4">
                <div class="controls d-flex flex-wrap gap-2 align-items-center mb-3">
                    <span>All scores calculate automatically if columns exist.</span>
                    <span id="wasmStatus" class="ms-auto small text-info">Loading WASM...</span>
                </div>
                <div class="mb-4">
                    <ol class="mb-0">
                        <li>
                            Upload any CSV with nutrient columns. If headers don't
                            match the expected names, you'll be prompted to map them
                            after the initial upload.
                        </li>
                        <li>Drag it below or use the file picker.</li>
                        <li>Download the scored file and review the charts.</li>
                    </ol>
                    <div class="alert alert-light border rounded-4 mt-3" role="note">
                        <strong>Sample template:</strong>
                        <a href="data/template.csv">template.csv</a> lists every
                        recognized column. Use it only as a reference for optional
                        column names.
                    </div>
                </div>
                <div id="dropzone" class="mb-3">Drag & drop CSV here, or click to select file</div>
                <div id="previewContainer">
                    <h3 id="previewTitle" style="display:none;">
                        Preview (first 5 rows)
                        <button id="clearBtn"
                                type="button"
                                class="btn-close float-end"
                                aria-label="Clear preview"
                                style="display:none"></button>
                    </h3>
                    <table id="previewTable">
                    </table>
                </div>
                <div class="d-flex gap-2 mb-2">
                    <button id="scoreBtn" class="btn btn-primary" disabled>Score</button>
                    <button id="downloadBtn" class="btn btn-secondary" disabled>Download CSV</button>
                </div>
                <div id="loading">⏳ Scoring in progress...</div>
                <div id="result"></div>
                <div id="charts"></div>
            </div>
        </main>
        <section class="container py-4" id="about">
            <div class="accordion" id="aboutAccordion">
                <div class="accordion-item">
                    <h2 class="accordion-header" id="aboutHeading">
                        <button class="accordion-button collapsed"
                                type="button"
                                data-bs-toggle="collapse"
                                data-bs-target="#aboutCollapse"
                                aria-expanded="false"
                                aria-controls="aboutCollapse">About this Project</button>
                    </h2>
                    <div id="aboutCollapse"
                         class="accordion-collapse collapse"
                         aria-labelledby="aboutHeading"
                         data-bs-parent="#aboutAccordion">
                        <div class="accordion-body">
                            <p>
                                The scoring methods featured on this platform are derived from the robust
                                <a href="https://github.com/jamesjiadazhan/dietaryindex"
                                   target="_blank"
                                   rel="noopener">Dietary Index</a>
                                R codebase created by James Jia Da Zhan, whose foundational contributions we gratefully acknowledge.
                                Leveraging generative AI and codex-driven configurations, we have modernized these methodologies into
                                an intuitive drag-and-drop web interface. Earlier revisions used Pyodide to run the Python code, but scoring now relies on a fast WebAssembly module compiled from Rust. This approach removes significant
                                technical and language barriers, enabling researchers from diverse backgrounds to seamlessly engage with validated nutritional scoring routines, without requiring any server setup or coding expertise.
                            </p>
                            <p>
                                Our codex-configured system integrates generative AI to facilitate transparent validation, robust self-correction,
                                and comprehensive refinement tools across the entire codebase. A key advantage of this design is built-in peer validation,
                                inherently provided through reliance on peer-reviewed scholarly publications, thus ensuring immediate credibility and trust.
                                These intrinsic validation processes accelerate the adoption and practical application of proven research methodologies.
                            </p>
                            <p>
                                We actively encourage critical feedback, validation testing, and innovative suggestions—whether verifying existing scoring
                                procedures or proposing new nutritional indices. Researchers and practitioners are invited to fork our repository, file issues,
                                and contribute actively to future improvements. Through open sharing of this collaborative AI-driven framework, HOBI and
                                <strong>Dr. Strath</strong> aim to cultivate an inclusive, transparent nutrition science community, bridging publication and
                                practice, and ultimately accelerating research that enhances public health outcomes.
                            </p>
                            <p>
                                <strong>Disclaimer:</strong> The majority, if not all, content on this platform—including written materials and both frontend
                                and backend code—is generated by AI. While innovative, not all content has undergone comprehensive human validation, including
                                this very disclaimer. This project is currently in early alpha development, with validation methods actively evolving. Users should independently verify all results obtained through these tools and employ them at their own risk. Your feedback—positive or critical—is invaluable in refining scientific validation methodologies facilitated by generative AI.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <script type="module">
    const dropzone = document.getElementById('dropzone');
    const resultBox = document.getElementById('result');
    const previewTable = document.getElementById('previewTable');
    const previewTitle = document.getElementById('previewTitle');
    const clearBtn = document.getElementById('clearBtn');
    const loading = document.getElementById('loading');
    const wasmStatus = document.getElementById('wasmStatus');
    const scoreBtn = document.getElementById('scoreBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    let currentData = null;
    let currentName = 'template.csv';
    let wasmReady = null;
    let required = [];
    let scoredCsv = null;
    async function loadWasm() {
      if (!wasmReady) {
        const load = () => import('./pkg/dietarycodex.js')
          .catch(() => import('./assets/wasm/dietarycodex.js'));
        wasmReady = load()
          .then(async m => {
            await m.default();
            return m;
          })
          .catch(err => {
            wasmStatus.textContent = 'WASM load failed';
            wasmStatus.className = 'ms-auto small text-danger';
            console.error('WASM init failed', err);
            throw err;
          });
      }
      return wasmReady;
    }


    function quantile(arr, q) {
      const sorted = arr.slice().sort((a, b) => a - b);
      const pos = (sorted.length - 1) * q;
      const lo = Math.floor(pos), hi = Math.ceil(pos);
      return sorted[lo] + (sorted[hi] - sorted[lo]) * (pos - lo);
    }
    function computeStats(values) {
      const n = values.length;
      const mean = values.reduce((a,b) => a + b, 0) / n;
      const sq = values.map(v => (v - mean)**2);
      const std = Math.sqrt(sq.reduce((a,b) => a + b, 0) / (n - 1));
      return {
        mean: mean.toFixed(2),
        std: std.toFixed(2),
        min: Math.min(...values).toFixed(2),
        max: Math.max(...values).toFixed(2),
        median: quantile(values,0.5).toFixed(2),
        quintiles: [0.2,0.4,0.6,0.8].map(q => quantile(values,q).toFixed(2))
      };
    }

    function csvToJson(text) {
      const lines = text.trim().split(/\r?\n/);
      const headers = lines[0].split(',').map(h => h.trim());
      return lines.slice(1).map(line => {
        const values = line.split(',');
        const obj = {};
        headers.forEach((h, i) => {
          const v = (values[i] ?? '').trim();
          if (v === '') {
            obj[h] = null;
          } else {
            const num = Number(v);
            obj[h] = isNaN(num) ? v : num;
          }
        });
        return obj;
      });
    }

    function jsonToCsv(data) {
      if (!data.length) return '';
      const headers = Object.keys(data[0]);
      const lines = data.map(row => headers.map(h => row[h]).join(','));
      return [headers.join(','), ...lines].join('\n');
    }

    function applyColumnMapping(data) {
      const map = JSON.parse(localStorage.getItem('colMap') || '{}');
      return data.map(row => {
        const out = { ...row };
        for (const [dst, src] of Object.entries(map)) {
          if (src in row && !(dst in row)) {
            out[dst] = row[src];
          }
        }
        return out;
      });
    }

    function showMappingUI(missing, headers) {
      const saved = JSON.parse(localStorage.getItem('colMap') || '{}');
      let html = '<h3>Map Columns</h3><form id="mapForm">';
      missing.forEach(col => {
        html += `<div class='mb-2'><label class='me-2'>${col}</label>`;
        html += `<select class='form-select d-inline w-auto' data-key='${col}'>`;
        html += "<option value=''>--</option>";
        headers.forEach(h => {
          const sel = saved[col] === h ? 'selected' : '';
          html += `<option ${sel}>${h}</option>`;
        });
        html += '</select></div>';
      });
      html += "<button type='submit' class='btn btn-primary mt-2'>Save Mapping</button></form>";
      resultBox.innerHTML = html;
      document.getElementById('mapForm').addEventListener('submit', e => {
        e.preventDefault();
        const selects = document.querySelectorAll('#mapForm select');
        selects.forEach(sel => {
          if (sel.value) saved[sel.dataset.key] = sel.value;
        });
        localStorage.setItem('colMap', JSON.stringify(saved));
        resultBox.innerHTML = '';
        computeFile(currentData, currentName);
      });
    }
    dropzone.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv';
      input.onchange = () => handleFile(input.files[0]);
      input.click();
    });
    clearBtn.addEventListener('click', () => {
      resultBox.innerHTML = '';
      previewTable.innerHTML = '';
      previewTitle.style.display = 'none';
      document.getElementById('charts').innerHTML = '';
      clearBtn.style.display = 'none';
    });
    dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('hover'); });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('hover'));
    dropzone.addEventListener('drop', e => {
      e.preventDefault(); dropzone.classList.remove('hover');
      if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
    });

    scoreBtn.addEventListener('click', () => {
      if (currentData) computeFile(currentData, currentName);
    });

    downloadBtn.addEventListener('click', () => {
      if (!scoredCsv) return;
      const blob = new Blob([scoredCsv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = currentName.replace(/\.csv$/, '') + '_scores.csv';
      a.click();
      URL.revokeObjectURL(url);
    });

    // Load bundled template on startup
    window.addEventListener('DOMContentLoaded', async () => {
      try {
        const wasm = await loadWasm();
        required = wasm.required_fields();
        wasmStatus.textContent = 'Local compute ready';
        wasmStatus.className = 'ms-auto small text-success';
      } catch (err) {
        // wasmStatus updated in loadWasm
        return;
      }
      try {
        const res = await fetch('./data/template.csv');
        if (!res.ok) throw new Error(`template load ${res.status}`);
        const text = await res.text();
        const file = new File([text], 'template.csv', { type: 'text/csv' });
        handleFile(file);
      } catch (err) {
        console.error('Could not preload template', err);
      }
    });

    async function handleFile(file) {
      resultBox.innerHTML = '';
      previewTable.innerHTML = '';
      previewTitle.style.display = 'none';
      document.getElementById('charts').innerHTML = '';
      clearBtn.style.display = 'none';
      loading.style.display = 'none';
      if (!file.name.toLowerCase().endsWith('.csv')) {
        resultBox.innerHTML = "<div class='error'>Only CSV files are supported.</div>";
        return;
      }
      currentName = file.name;
      const text = await file.text();
      currentData = csvToJson(text);
      const rows = text.trim().split('\n').map(r => r.split(','));
      const headers = rows[0];
      const sample = rows.slice(1,6);
      let html = '<tr>' + headers.map(h => `<th>${h}</th>`).join('') + '</tr>';
      sample.forEach(r => html += '<tr>' + r.map(c => `<td>${c}</td>`).join('') + '</tr>');
      previewTable.innerHTML = html;
      previewTitle.style.display = 'block';
      clearBtn.style.display = 'inline-block';
      scoreBtn.disabled = false;
    }

    async function computeFile(data, name) {
      loading.style.display = 'block';
      try {
        const mapped = applyColumnMapping(data);
        const wasm = await loadWasm();
        const missing = wasm.missing_fields(JSON.stringify(mapped[0]||{}));
        if (missing.length) {
          resultBox.innerHTML = `<div class='error'>Missing columns: ${missing.join(', ')}</div>`;
          downloadBtn.disabled = true;
          return;
        }
        const scoreRows = wasm.score_json(JSON.stringify(mapped));
        const combined = mapped.map((r,i) => ({...r, ...(scoreRows[i]||{})}));
        const csvText = jsonToCsv(combined);
        const scoreNames = Object.keys(scoreRows[0] || {});
        let summary = '<h3>Summary Statistics:</h3><ul>';
        scoreNames.forEach(name => {
          const vals = scoreRows.map(r => r[name]).filter(v => v !== null && !isNaN(v));
          if (!vals.length) return;
          const s = computeStats(vals);
          summary += `<li><b>${name}</b> – mean: ${s.mean}, std: ${s.std}, min: ${s.min}, max: ${s.max}, median: ${s.median}, quintiles: ${s.quintiles.join(', ')}</li>`;
          const chartDiv = document.createElement('div');
          document.getElementById('charts').append(chartDiv);
          Plotly.newPlot(chartDiv,[{x:vals,type:'histogram',name}],{title:`${name} Distribution`,margin:{t:40}}, {responsive:true});
        });
        summary += '</ul>';
        resultBox.innerHTML = summary;
        scoredCsv = csvText;
        downloadBtn.disabled = false;
      } catch(err) {
        console.error('Scoring failed', err);
        let msg = err instanceof Error ? `${err.name}: ${err.message}` : String(err);
        resultBox.innerHTML = `<div class='error'><b>${msg}</b></div>`;
      } finally {
        loading.style.display = 'none';
      }
    }
        </script>
    </body>
</html>
