<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
              rel="stylesheet" />
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
              rel="stylesheet" />
        <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
        <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
        <script>if ("serviceWorker" in navigator){navigator.serviceWorker.register("sw.js").catch(()=>{});}</script>
        <link href="assets/style.css" rel="stylesheet" />
    </head>
    <body>
        <header class="hero text-center">
            <a href="https://hobi.med.ufl.edu/"
               target="_blank"
               rel="noopener"
               style="display:block;
                      text-align:center;
                      margin-top:2rem">
                <img src="assets/UF_gen_ai.png" alt="UF Logo" />
            </a>
            <p class="lead">
                The Department of Health Outcomes & Biomedical Informatics
                (HOBI) at the University of Florida advances research and
                data science for better care. Tap the logo to explore our
                programs and open-source tools.
            </p>
            <p class="lead mt-3">
                OpenAI released its Codex research preview in May 2025 and expanded it to ChatGPT users in June. HOBI quickly modernized prior code under <strong>Dr. Larissa Strath</strong>'s leadership, sharing this project so researchers worldwide can collaborate and advance health data science.
            </p>
            <a class="btn btn-primary hero-btn"
               href="https://hobi.med.ufl.edu/"
               target="_blank">Learn more about HOBI</a>
        </header>
        <section class="container py-4" id="about">
            <h2>About this project</h2>
            <p>
                The scoring routines used on this site trace back to the
                excellent
                <a href="https://github.com/jamesjiadazhan/dietaryindex"
                   target="_blank"
                   rel="noopener">Dietary Index</a>
                R codebase by James Jia Da Zhan. We thank that project for
                laying the scientific foundation.
            </p>
            <p>
                Here we modernize those methods into a seamless drag-and-drop
                web interface. Everything runs locally through Pyodide, letting
                you test diet-quality algorithms with zero server setup. The
                approach demonstrates how generative AI and open-source
                collaboration can translate proven academic code into a
                low-code environment anyone can use.
            </p>
            <p>
                Questions are welcome—from verifying calculations to suggesting
                new indices. We invite researchers to fork the repository, file
                issues, and help shape the roadmap. By sharing this work
                publicly, HOBI and <strong>Dr. Strath</strong> aim to foster a
                community around transparent nutrition science and early
                adoption of emerging AI tools.
            </p>
        </section>
        <main class="container py-4">
            <div class="controls d-flex flex-wrap gap-2 align-items-center mb-3">
                <span>All scores calculate automatically if columns exist.</span>
                <span id="pyStatus" class="ms-auto small text-info">Loading Pyodide...</span>
            </div>
            <div class="mb-4">
                <ol class="mb-0">
                    <li>
                        Prepare your CSV using
                        <a href="assets/template.csv">the provided template</a>
                        (download and replace the sample values with your own
                        nutrient data).
                    </li>
                    <li>Drag it below or use the file picker.</li>
                    <li>Download the scored file and review the charts.</li>
                </ol>
                <div class="alert alert-light border rounded-4 mt-3" role="note">
                    <strong>About the template:</strong> this CSV outlines all
                    required nutrient columns. Use it as a guide so the scoring
                    engine recognizes your data. Delete the example rows and add
                    your own records before uploading.
                </div>
            </div>
            <div id="dropzone" class="mb-3">Drag & drop CSV here, or click to select file</div>
            <div id="previewContainer">
                <h3 id="previewTitle" style="display:none;">
                    Preview (first 5 rows)
                    <button id="clearBtn"
                            type="button"
                            class="btn-close float-end"
                            aria-label="Clear preview"
                            style="display:none"></button>
                </h3>
                <table id="previewTable">
                </table>
            </div>
            <button id="scoreBtn" class="btn btn-primary mb-2" disabled>Score & Download</button>
            <div id="loading">⏳ Scoring in progress...</div>
            <div id="result"></div>
            <div id="charts"></div>
        </main>
        <script>
    const dropzone = document.getElementById('dropzone');
    const resultBox = document.getElementById('result');
    const previewTable = document.getElementById('previewTable');
    const previewTitle = document.getElementById('previewTitle');
    const clearBtn = document.getElementById('clearBtn');
    const loading = document.getElementById('loading');
    const pyStatus = document.getElementById('pyStatus');
    const scoreBtn = document.getElementById('scoreBtn');
    let currentData = null;
    let currentName = 'template.csv';
    let pyReady = null;
    async function loadPy() {
      if (!pyReady) {
        pyReady = loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/' })
          .then(async py => {
            await py.loadPackage(['pandas', 'numpy']);
            const files = ['base.py','dii.py','dash.py','mind.py','hei.py','dii_parameters.json'];
            for (const f of files) {
              const resp = await fetch('./compute/' + f);
              const text = await resp.text();
              const dir = '/tmp/compute';
              try { py.FS.stat(dir); } catch { py.FS.mkdirTree(dir); }
              py.FS.writeFile(dir + '/' + f, text);
            }
            await py.runPythonAsync("import sys; sys.path.insert(0, '/tmp')");
            return py;
          });
      }
      return pyReady;
    }


    function quantile(arr, q) {
      const sorted = arr.slice().sort((a, b) => a - b);
      const pos = (sorted.length - 1) * q;
      const lo = Math.floor(pos), hi = Math.ceil(pos);
      return sorted[lo] + (sorted[hi] - sorted[lo]) * (pos - lo);
    }
    function computeStats(values) {
      const n = values.length;
      const mean = values.reduce((a,b) => a + b, 0) / n;
      const sq = values.map(v => (v - mean)**2);
      const std = Math.sqrt(sq.reduce((a,b) => a + b, 0) / (n - 1));
      return {
        mean: mean.toFixed(2),
        std: std.toFixed(2),
        min: Math.min(...values).toFixed(2),
        max: Math.max(...values).toFixed(2),
        median: quantile(values,0.5).toFixed(2),
        quintiles: [0.2,0.4,0.6,0.8].map(q => quantile(values,q).toFixed(2))
      };
    }

    function csvToJson(text) {
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',');
      return lines.slice(1).map(line => {
        const values = line.split(',');
        const obj = {};
        headers.forEach((h, i) => {
          const v = (values[i] ?? '').trim();
          if (v === '') {
            obj[h] = null;
          } else {
            const num = Number(v);
            obj[h] = isNaN(num) ? v : num;
          }
        });
        return obj;
      });
    }

    function jsonToCsv(data) {
      if (!data.length) return '';
      const headers = Object.keys(data[0]);
      const lines = data.map(row => headers.map(h => row[h]).join(','));
      return [headers.join(','), ...lines].join('\n');
    }
    dropzone.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv';
      input.onchange = () => handleFile(input.files[0]);
      input.click();
    });
    clearBtn.addEventListener('click', () => {
      resultBox.innerHTML = '';
      previewTable.innerHTML = '';
      previewTitle.style.display = 'none';
      document.getElementById('charts').innerHTML = '';
      clearBtn.style.display = 'none';
    });
    dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('hover'); });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('hover'));
    dropzone.addEventListener('drop', e => {
      e.preventDefault(); dropzone.classList.remove('hover');
      if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
    });

    scoreBtn.addEventListener('click', () => {
      if (currentData) computeFile(currentData, currentName);
    });

    // Load bundled template on startup
    window.addEventListener('DOMContentLoaded', async () => {
      await loadPy();
      pyStatus.textContent = 'Local compute ready';
      pyStatus.className = 'ms-auto small text-success';
      try {
        const res = await fetch('./assets/template.csv');
        if (!res.ok) throw new Error(`template load ${res.status}`);
        const text = await res.text();
        const file = new File([text], 'template.csv', { type: 'text/csv' });
        handleFile(file);
      } catch (err) {
        console.error('Could not preload template', err);
      }
    });

    async function handleFile(file) {
      resultBox.innerHTML = '';
      previewTable.innerHTML = '';
      previewTitle.style.display = 'none';
      document.getElementById('charts').innerHTML = '';
      clearBtn.style.display = 'none';
      loading.style.display = 'none';
      if (!file.name.toLowerCase().endsWith('.csv')) {
        resultBox.innerHTML = "<div class='error'>Only CSV files are supported.</div>";
        return;
      }
      currentName = file.name;
      const text = await file.text();
      currentData = csvToJson(text);
      const rows = text.trim().split('\n').map(r => r.split(','));
      const headers = rows[0];
      const sample = rows.slice(1,6);
      let html = '<tr>' + headers.map(h => `<th>${h}</th>`).join('') + '</tr>';
      sample.forEach(r => html += '<tr>' + r.map(c => `<td>${c}</td>`).join('') + '</tr>');
      previewTable.innerHTML = html;
      previewTitle.style.display = 'block';
      clearBtn.style.display = 'inline-block';
      scoreBtn.disabled = false;
    }

    async function computeFile(data, name) {
      loading.style.display = 'block';
      try {
        const py = await loadPy();
        const jsonData = JSON.stringify(data).replace(/'/g, "\\'");
        const pyRes = await py.runPythonAsync(`
import pandas as pd, json
from compute.dii import calculate_dii, DII_PARAMETER_KEYS
from compute.mind import calculate_mind, MIND_COMPONENT_KEYS
from compute.hei import calculate_hei_2015, HEI_COMPONENT_KEYS
from compute.dash import calculate_dash, DASH_COMPONENT_KEYS
from compute.base import compute_summary_stats
data = json.loads('${jsonData}')
df = pd.DataFrame(data)
stats = {}
missing = {}
def check(cols):
    return [c for c in cols if c not in df.columns]

if not check(DII_PARAMETER_KEYS):
    df['DII'] = calculate_dii(df)
    stats['DII'] = compute_summary_stats(df, ['DII'])['DII']
else:
    missing['DII'] = check(DII_PARAMETER_KEYS)

if not check(MIND_COMPONENT_KEYS):
    df['MIND'] = calculate_mind(df)
    stats['MIND'] = compute_summary_stats(df, ['MIND'])['MIND']
else:
    missing['MIND'] = check(MIND_COMPONENT_KEYS)

if not check(HEI_COMPONENT_KEYS):
    df['HEI_2015'] = calculate_hei_2015(df)
    stats['HEI_2015'] = compute_summary_stats(df, ['HEI_2015'])['HEI_2015']
else:
    missing['HEI_2015'] = check(HEI_COMPONENT_KEYS)

if not check(DASH_COMPONENT_KEYS):
    df['DASH'] = calculate_dash(df)
    stats['DASH'] = compute_summary_stats(df, ['DASH'])['DASH']
else:
    missing['DASH'] = check(DASH_COMPONENT_KEYS)

out = {'csv': df.to_csv(index=False), 'stats': stats, 'missing': missing}
json.dumps(out)
`);
        const info = JSON.parse(pyRes);
        const csvText = info.csv;
        const rows = csvText.trim().split('\n').map(r => r.split(','));
        const idx = rows[0].reduce((m,h,i) => (m[h]=i,m), {});
        const computed = Object.keys(info.stats || {});
        const missing = info.missing || {};
        if (computed.length === 0) {
          const allMissing = [...new Set(Object.values(missing).flat())];
          resultBox.innerHTML = `<div class='alert alert-danger'>Missing required columns (${allMissing.length}): ${allMissing.join(', ')}</div>`;
          return;
        }
        let summary = '<h3>Summary Statistics:</h3><ul>';
        computed.forEach(name => {
          const vals = rows.slice(1).map(r => parseFloat(r[idx[name]])).filter(v => !isNaN(v));
          const s = info.stats[name];
          summary += `<li><b>${name}</b> – mean: ${parseFloat(s.mean).toFixed(2)}, std: ${parseFloat(s.std).toFixed(2)}, min: ${parseFloat(s.min).toFixed(2)}, max: ${parseFloat(s.max).toFixed(2)}, median: ${parseFloat(s.median).toFixed(2)}, quintiles: ${s.quintiles.map(q=>parseFloat(q).toFixed(2)).join(', ')}</li>`;
          const chartDiv = document.createElement('div');
          document.getElementById('charts').append(chartDiv);
          Plotly.newPlot(chartDiv,[{x:vals,type:'histogram',name}],{title:`${name} Distribution`,margin:{t:40}}, {responsive:true});
        });
        summary += '</ul>';
        Object.entries(missing).forEach(([n, cols]) => {
          summary += `<div class='alert alert-warning mt-2'>${n} missing columns: ${cols.join(', ')}</div>`;
        });
        resultBox.innerHTML = summary;
        const blob = new Blob([csvText], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name.replace(/\.csv$/, '') + '_scores.csv';
        a.click();
        URL.revokeObjectURL(url);
      } catch(err) {
        console.error('Scoring failed', err);
        let msg = err instanceof Error ? `${err.name}: ${err.message}` : String(err);
        resultBox.innerHTML = `<div class='error'><b>${msg}</b></div>`;
      } finally {
        loading.style.display = 'none';
      }
    }
        </script>
    </body>
</html>
